#include <iostream>
#include <fstream>
#include <Windows.h>
#include <conio.h>
using namespace std;

bool gameOver, isReplay; // Закончена игра или нет?; Играть ещё или нет?
const int width = 50, height = 26; // Ширина и высота игрового поля
int x, y; // Координаты головы змейки
int fruitX, fruitY; // Координаты
int score, typeOfGame, speed; // Счёт игрока; Тип Фигры (столкновение со стенами - смерть или нет?)
int tailX[100], tailY[100], nTail; // Координаты сегментов хвоста; Длина хвоста
enum Direction { STOP = 0, LEFT, RIGHT, UP, DOWN }; // Состояния змейки: покой и движение (его направления)
Direction dir; // Состояния змейки: покой и движение (его направления)
string bufer; // Буферная строка

void Setup() { // Стартовая функция; Делает первые настройки игры
	MoveWindow(GetConsoleWindow(), 0, 0, 1920, 1050, true); // Установка консоли на весь экран
	srand(static_cast<unsigned int>(time(0))); // Запуск генератора случайных чисел
	gameOver = false; // Игра только начинается, поэтому она не закончена
	dir = STOP; // Сначала змейка стоит на месте
	x = width / 2 - 1; y = height / 2 - 1; // Координаты головы змейки
	fruitX = rand() % width; fruitY = rand() % height; // Рандомные координаты для фрукта
	score = 0; // Счёт в начале игры равен нулю
	nTail = 0; // Кол-во сегментов - ноль
}

void Draw() { // Вывод всего игрового поля
		switch (speed) { // Проверка на уровень сложности
		case 1: Sleep(300); break; // Задержка 300 миллисекунд
		case 2: Sleep(150); break; // Задержка 150 миллисекунд
		case 3: Sleep(50); break; // Задержка 50 миллисекунд
		}
		system("cls"); // Очистка экрана

		bufer += "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\t\t\t\t\t\t\t\t\t\t  ";
		for (int i = 0; i < width + 1; i++) {// Запись в буфер верхней границы карты
			bufer += "=";
		}
		bufer += "\n";

		for (int i = 0; i < height; i++) {// Запись в буфер самого поля и его боковых границ
			for (int j = 0; j < width; j++) {
				// Запись в буфер боковых границ карты
				if (j == 0) {
					bufer += "\t\t\t\t\t\t\t\t\t\t\t  "; bufer += "|";
				}
				else if (j == width - 1) {
					bufer += "|";
				}
				if (i == y && j == x) bufer += 1; // Запись в буфер головы змейки
				else if (i == fruitY && j == fruitX) bufer += "¤"; // Запись в буфер яблока
				else {
					bool print = false; // Записывается ли в буфер сегмент хвоста? По умолчанию - нет
					for (int k = 0; k < nTail; k++) {
						if (tailX[k] == j && tailY[k] == i) {
							print = true; // Сегмент хвоста записывается
							bufer += "o"; // Запись в буфер сегмента хвоста
						}
					}
					if (!print) // Если в данной точке нет сегмента хвоста, записать в буфер пробел
						bufer += " ";
				}
			}
			bufer += "\n";
		}

		bufer += "\t\t\t\t\t\t\t\t\t\t\t  ";
		for (int i = 0; i < width + 1; i++) {// Запись в буфер нижней границы карты
			bufer += "=";
		}
		bufer += "\n";

		cout << bufer; bufer = ""; // Вывод буферной строки
		cout << "\n\t\t\t\t\t\t\t\t\t\t\t\t\t     Ваш счёт: " << score; // Вывод текущего счёта игрока
}

void Input() { // Управление игроком игрой
	if (_kbhit()) { // Если нажата клавиша
		switch (_getch()) // Считать код этой клавиши 
		{
		case 'w': // Если клавиша W - направление ВВЕРХ
			if (dir != DOWN) dir = UP;
			break;
		case 72: // Если клавиша [СТРЕЛКА ВВЕРХ] - направление ВВЕРХ
			if (dir != DOWN) dir = UP;
			break;
		case 'a': // Если клавиша A - направление ВЛЕВО
			if (dir != RIGHT) dir = LEFT;
			break;
		case 75: // Если клавиша [СТРЕЛКА ВЛЕВО] - направление ВЛЕВО
			if (dir != RIGHT) dir = LEFT;
			break;
		case 's': // Если клавиша S - направление ВНИЗ
			if (dir != UP) dir = DOWN;
			break;
		case 80: // Если клавиша [СТРЕЛКА ВНИЗ] - направление ВНИЗ
			if (dir != UP) dir = DOWN;
			break;
		case 'd': // Если клавиша D - направление ВПРАВО
			if (dir != LEFT) dir = RIGHT;
			break;
		case 77: // Если клавиша [СТРЕЛКА ВПРАВО] - направление ВПРАВО
			if (dir != LEFT) dir = RIGHT;
			break;
		case 'p': // Если клавиша P - пауза
			dir = STOP; // Змейка остановилась
			break;
		case 'x': // Если клавиша X - выход из игры
			gameOver = true; // Игра окончена
			break;
		}
	}
}

void Game() { // Сама игра (функция, превращающяя остальные функции в нормальную игру)
	if (dir != STOP) { // Выполнять, если игра не на паузе
		int prevX = tailX[0], prevY = tailY[0]; // Координаты головы (Первого сегмента)
		int prev2X, prev2Y; // Координаты следующего сегмента
		tailX[0] = x; tailY[0] = y; // Координаты первого сегмента змейки - координты головы
		for (int i = 1; i < nTail; i++) { // Передвижение каждого сегмента змейки
			prev2X = tailX[i]; prev2Y = tailY[i]; // Координаты следующего сегмента записываются в массив
			tailX[i] = prevX; tailY[i] = prevY; // Координаты следующего сегмента для слеследующей иттерации - координаты первого сегмента
			prevX = prev2X; prevY = prev2Y; // Координаты следующего сегмента приравниваются к координатом первого. Идёт передвижение следующешго сегмента на позицию первого
		}
		switch (dir) { // Изменение координаты головы змейки в зависимости от направления
		case LEFT:
			x--;
			break;
		case RIGHT:
			x++;
			break;
		case UP:
			y--;
			break;
		case DOWN:
			y++;
			break;
		}

		if (typeOfGame == 1) { // Если выбран тип игры №1 - змейка умирает при столкновении со стеной
			if (x >= width - 1 || x < 0 || y > height || y < 0) gameOver = true;
		}
		else if (typeOfGame == 2) { //Если выбран тип игры №2 -
			if (x >= width - 1) x = 0; // Если столкнулась с правой стенкой - координата x головы приравнивается к координате левой стенки
			else if (x < 0) x = width - 2; // Если столкнулась с левой стенкой - координата x головы приравнивается к координате правой стенки
			if (y >= height) y = 0; // Если столкнулась с потолком - координата y головы приравнивается к координате пола
			else if (y < 0) y = height - 1; // Если столкнулась с полом - координата y головы приравнивается к координате потолка
		}

		for (int i = 0; i < nTail; i++) { // Если координаты любого сегмена совпадают с координатами другого сегмента
			if (tailX[i] == x && tailY[i] == y) {
				gameOver = true; // Конец игры
			}
		}

		if (x == fruitX && y == fruitY) { // Если координаты головы совпадают с координатами яблока
			score += 10; // Увеличение счёта
			srand(static_cast<unsigned int>(time(0))); // Запуск генератора случайных чисел
			fruitX = rand() % width; fruitY = rand() % height; // Рандомные координаты для фрукта
			nTail++; // Увеличение длины змейки
		}
	}
}

int main() {
	MoveWindow(GetConsoleWindow(), 600, 325, 700, 400, true); // Установка консоли
	setlocale(0, ""); // Установка русского языка

	cout << "\t\tSnake Game v1.0\n\tПриветствуем вас в игре Змейка!\n Какой тип игры вам больше нравится? (Введите цифру)\n" <<
		"1. При столкновении со стеной змейка умирает\n" << "2. Змейка, проходя через границу карты, оказывается на противоположной стороне\n";
	cin >> typeOfGame; // Ввод типа игры
	system("cls"); // Очистка консоли
	cout << "Выберите скорость игры: \n" << "1. Медленно\n" << "2. Средне\n" << "3. Быстро\n";
	cin >> speed; // Ввод скорости игры
	system("cls"); // Очистка консоли

	cout << "Управление: \n" << "Вверх-Влево-Вниз-Вправо - " <<" WASD / Стрелки"
		<< "\n Пауза - P (англ.)\tАвтовыход из игры - X (англ.)\n";
	system("pause");// Пауза для чтения

	do {
		Setup(); // Запуск стартовой функции
		Draw(); // Запуск функции вывода
		while (!gameOver) { // Пока игра не завершена
			if (dir != STOP) Draw(); // Запуск функции вывода, если игра не на паузе
			Input(); // Запуск функции считывания ввода от игрока
			Game(); // Запуск основной игровой функции
		}
		ofstream out("data.txt", ios::app); // Открытие файла с результатами
		out << nTail + 1 << " - Длина змейки. " << score << " - Общий счёт. " << typeOfGame << " Тип игры\n";// Запись данных в файл с результатами
		MoveWindow(GetConsoleWindow(), 600, 325, 700, 400, true); // Установка консоли
		cout << "\n\t\t\tИграть ещё раз? \n\t\t\tYes - 1 | No - 0\n";
		cin >> isReplay; // Играть ещё раз?
		if (isReplay) {// Если играть ещё раз, то
			Setup(); // Настройки заново
		}
	} while (isReplay); // Возможность играть ещё раз

}